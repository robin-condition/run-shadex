// Lambdas are declared like this.
DEF test: (a, b) => {
    // The only statements are assignments.
    let myfn = (x, y) => {
        let out = x + y;
    };
    let dat = (a: a, b: b);
    // Identifiers can be scoped.
    // Functions MUST be called with named arguments. No alternative.
    let blah = core::test(t: myfn);
    // Values can have function members
    let t = myfn(x: 2).val<a,b>();
    a
}

DEF add: (a, b) => {
    a.val() + b.val()
}

DEF attrx: (x) => {x}
DEF attry: (y) => {y}

DEF sum: (f) => {
    let j = f.val<x>();
    j(x: 2).val() + j(x: 3).val()
}

DEF vector: (x, y, z) => {
    (comp) => {
        core::or(cond: () => {comp.val() == 0}, a: x, b: core::or(cond: () => {comp.val() == 1}, a: y, b: z))
    }
}

DEF demoprogram: () => {
    let myx = attrx;
    let myy = attry;
    (x, y) => {
        let resx = attrx(x: x);
        let resy = attry(y: y);
        vector(x: resx, y: resy, z: add(a: resx, b: resy))
    }
}

//
